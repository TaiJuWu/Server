'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const util = require("util");
const uuid = require("uuid");
const domain = require("domain");
const EventEmitter = require("events");
const log = {
    info: console.log.bind(console, 'haven stdout:'),
    error: console.error.bind(console, 'haven stderr:'),
};
const getErrorObject = function (e) {
    if (e && typeof e.stack === 'string' && typeof e.message === 'string') {
        return e;
    }
    if (e && !(e instanceof Error)) {
        return new Error(typeof e === 'string' ? e : util.inspect(e));
    }
    return e || new Error('Unknown/falsy error, this is a dummy error.');
};
const handleGlobalErrors = (resMap, opts) => {
    const auto = !(opts && opts.auto === false);
    const getErrorTrace = function (e) {
        if (opts && opts.showStackTracesInResponse === false) {
            return e && e.message || util.inspect(e);
        }
        return e && e.stack || util.inspect(e);
    };
    process.on('uncaughtException', e => {
        const d = process.domain;
        const emitter = exports.haven.emitter;
        if (d && d.havenUuid) {
            let res = resMap.get(d.havenUuid);
            if (res) {
                if (res.headersSent) {
                    log.error('Warning, response headers were already sent for request. Error:', util.inspect(e));
                }
                if (!auto || res.headersSent) {
                    return emitter.emit('exception', {
                        message: 'Uncaught exception was pinned to a request/response pair.',
                        error: getErrorObject(e),
                        pinned: true,
                        uncaughtException: true,
                        request: res.req,
                        response: res,
                        domain: d
                    });
                }
                return res.status(500).json({
                    trappedByDomainHavenMiddleware: true,
                    uncaughtException: true,
                    error: getErrorTrace(e)
                });
            }
        }
        emitter.emit('exception', {
            message: 'Uncaught exception could NOT be pinned to a request/response pair.',
            error: getErrorObject(e),
            pinned: false,
            uncaughtException: true,
            request: null,
            response: null,
            domain: d || null
        });
        if (auto) {
            log.error('Uncaught exception could NOT be pinned to a request/response:', util.inspect(e));
            log.error('It is possible that the response has finished writing before the error occurs.');
        }
    });
    process.on('unhandledRejection', (e, p) => {
        if (p && p.domain && p.domain.havenUuid) {
            let res = resMap.get(p.domain.havenUuid);
            if (res) {
                if (res.headersSent) {
                    log.error('Warning, response headers were already sent for request. Error:', util.inspect(e));
                }
                if (!auto || res.headersSent) {
                    return exports.haven.emitter.emit('rejection', {
                        message: 'Unhandled rejection was pinned to a request/response.',
                        error: getErrorObject(e),
                        unhandledRejection: true,
                        pinned: true,
                        request: res.req,
                        response: res,
                        promise: p,
                        domain: p.domain
                    });
                }
                return res.status(500).json({
                    trappedByDomainHavenMiddleware: true,
                    unhandledRejection: true,
                    error: getErrorTrace(e)
                });
            }
        }
        exports.haven.emitter.emit('rejection', {
            message: 'Unhandled rejection could NOT be pinned to a request/response.',
            error: getErrorObject(e),
            pinned: false,
            unhandledRejection: true,
            request: null,
            response: null,
            promise: p || null,
            domain: p && p.domain || null
        });
        if (auto) {
            log.error('Unhandled rejection could NOT be pinned to a request/response:', util.inspect(e));
            log.error('It is possible that the response has finished writing before the error occurs.');
        }
    });
};
let registerCount = 0;
exports.haven = (opts) => {
    if (++registerCount > 1) {
        throw new Error('Haven middleware was registered more than once. Haven middleware should only be use in one place.');
    }
    const resMap = new Map();
    const auto = !(opts && opts.auto === false);
    if (!(opts && opts.handleGlobalErrors === false)) {
        handleGlobalErrors(resMap, opts);
    }
    const getErrorTrace = (e) => {
        if (opts && opts.showStackTracesInResponse === false) {
            return e && e.message || util.inspect(e || 'no error trace available');
        }
        return e && e.stack || util.inspect(e || 'no error trace available');
    };
    return (req, res, next) => {
        const d = domain.create();
        const v = d.havenUuid = uuid.v4();
        resMap.set(v, res);
        res.once('finish', function () {
            resMap.delete(d.havenUuid);
            d.exit();
            d.removeAllListeners();
        });
        d.once('error', function (e) {
            if (auto) {
                if (res.headersSent) {
                    log.error('Warning, headers already sent for response. Error:', util.inspect(e));
                    return;
                }
                return res.status(500).json({
                    trappedByDomainHavenMiddleware: true,
                    error: getErrorTrace(e)
                });
            }
            exports.haven.emitter.emit('trapped', {
                message: 'Uncaught exception was pinned to a request/response pair.',
                error: getErrorObject(e),
                pinned: true,
                uncaughtException: true,
                request: req,
                response: res,
                domain: d || null
            });
        });
        d.run(next);
    };
};
exports.haven.emitter = new EventEmitter();
const onAny = (v) => {
    exports.haven.emitter.emit('blunder', v);
};
exports.haven.emitter.on('rejection', onAny);
exports.haven.emitter.on('exception', onAny);
exports.haven.emitter.on('trapped', onAny);
exports.default = exports.haven;
exports.r2gSmokeTest = function () {
    return true;
};
